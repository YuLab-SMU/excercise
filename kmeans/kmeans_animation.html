<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>K-means Algorithm Animation</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial; margin: 0; display: flex; height: 100vh; }
    #left { width: 68%; background: #fafafa; display:flex; flex-direction:column; align-items:center; justify-content:center; }
    #canvas-wrap { width: 90%; max-width:900px; background: white; border: 1px solid #ddd; padding: 12px; box-shadow: 0 6px 20px rgba(30,30,30,0.06); }
    canvas { display:block; width:100%; height:600px; background: linear-gradient(180deg,#fff,#fcfcff); }
    #right { width:32%; padding:18px; box-sizing:border-box; background:#fff; border-left:1px solid #eee; }
    h1 { font-size:18px; margin:0 0 8px 0; }
    .controls { margin-top:12px; display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .control-row { margin-bottom:12px; }
    label { font-size:13px; display:block; margin-bottom:6px; }
    input[type=range] { width:100%; }
    button { padding:8px 12px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    button.primary { background:#2563eb; color:white; border-color:#2563eb; }
    small.note { color:#666; }
    .legend { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .legend .item { display:flex; align-items:center; gap:6px; }
    .dot { width:14px; height:14px; border-radius:50%; }
    footer { margin-top:12px; font-size:12px; color:#666; }
  </style>
</head>
<body>
  <div id="left">
    <div id="canvas-wrap">
      <canvas id="c"></canvas>
    </div>
  </div>
  <div id="right">
    <h1>K-means Algorithm — Interactive Animation</h1>
    <p>可视化 K-means 算法的主要步骤：<br>- 随机初始化中心点（centroids）<br>- 将点分配到最近中心（assignment）<br>- 更新中心为簇内均值（update）<br>- 重复直到收敛</p>

    <div class="control-row">
      <label>Number of clusters (k): <span id="kval">3</span></label>
      <input id="k" type="range" min="1" max="8" value="3" />
    </div>

    <div class="control-row">
      <label>Number of points: <span id="nval">200</span></label>
      <input id="n" type="range" min="20" max="800" value="200" />
    </div>

    <div class="controls">
      <button id="play" class="primary">Play</button>
      <button id="step">Step</button>
      <button id="reset">Reset</button>
      <button id="randomize">Randomize Points</button>
    </div>

    <div style="margin-top:10px">
      <label>Animation speed (ms per step)</label>
      <input id="speed" type="range" min="50" max="1500" value="500" />
    </div>

    <div class="legend" id="legend"></div>

    <footer>
      Tip: 拖动右侧控件改变 k 或样本数，按 <strong>Play</strong> 自动运行，按 <strong>Step</strong> 单步执行一次 assignment/update。
    </footer>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  function resize() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Controls
  const kSlider = document.getElementById('k');
  const kval = document.getElementById('kval');
  const nSlider = document.getElementById('n');
  const nval = document.getElementById('nval');
  const playBtn = document.getElementById('play');
  const stepBtn = document.getElementById('step');
  const resetBtn = document.getElementById('reset');
  const randBtn = document.getElementById('randomize');
  const speedSlider = document.getElementById('speed');
  const legendDiv = document.getElementById('legend');

  let width = canvas.width / dpr - 20;
  let height = canvas.height / dpr - 20;

  // Data
  function randomNormal(mu=0, sigma=1){
    // Box-Muller
    let u = 0, v = 0;
    while(u === 0) u = Math.random();
    while(v === 0) v = Math.random();
    return mu + sigma * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0*Math.PI*v);
  }

  function generatePoints(n){
    const pts = [];
    // create several gaussian blobs for nicer demo
    const centers = [
      {x:0.25*width, y:0.25*height},
      {x:0.7*width, y:0.2*height},
      {x:0.45*width, y:0.65*height},
      {x:0.8*width, y:0.75*height},
      {x:0.15*width, y:0.8*height}
    ];
    for(let i=0;i<n;i++){
      // pick a blob
      const b = Math.floor(Math.random()*centers.length);
      const cx = centers[b].x + randomNormal(0, width*0.04);
      const cy = centers[b].y + randomNormal(0, height*0.04);
      pts.push({x:cx, y:cy, cluster: -1});
    }
    return pts;
  }

  function randColor(i){
    const palette = ["#ef4444","#f97316","#f59e0b","#10b981","#3b82f6","#6366f1","#ec4899","#14b8a6"];
    return palette[i % palette.length];
  }

  let points = generatePoints(parseInt(nSlider.value,10));
  let k = parseInt(kSlider.value,10);
  let centroids = [];
  let animation = null;
  let playing = false;
  let stepPhase = 'assign'; // or 'update'

  function initCentroids(){
    centroids = [];
    for(let i=0;i<k;i++){
      // pick random point as initial centroid
      const p = points[Math.floor(Math.random()*points.length)];
      centroids.push({x:p.x + (Math.random()-0.5)*20, y:p.y + (Math.random()-0.5)*20, id:i});
    }
  }

  function assignClusters(){
    for(const p of points){
      let best = -1, bestd = Infinity;
      for(const c of centroids){
        const dx = p.x - c.x, dy = p.y - c.y;
        const d = dx*dx + dy*dy;
        if(d < bestd){ bestd = d; best = c.id; }
      }
      p.cluster = best;
    }
  }

  function updateCentroids(){
    const sums = Array.from({length:k}, () => ({x:0,y:0,n:0}));
    for(const p of points){
      if(p.cluster >=0 && p.cluster < k){
        sums[p.cluster].x += p.x;
        sums[p.cluster].y += p.y;
        sums[p.cluster].n += 1;
      }
    }
    for(let i=0;i<k;i++){
      if(sums[i].n>0){
        // smooth movement: move centroid partway to new mean for nicer animation
        const nx = sums[i].x / sums[i].n;
        const ny = sums[i].y / sums[i].n;
        centroids[i].nx = nx; centroids[i].ny = ny;
      } else {
        // if empty cluster, relocate randomly
        centroids[i].nx = Math.random()*width; centroids[i].ny = Math.random()*height;
      }
    }
  }

  function stepOnce(){
    if(stepPhase === 'assign'){
      assignClusters();
      stepPhase = 'update';
    } else {
      updateCentroids();
      // animate centroid move to nx,ny
      animateCentroidMove().then(()=>{
        // finalize new positions
        for(const c of centroids){ if(c.nx!==undefined) { c.x = c.nx; c.y = c.ny; delete c.nx; delete c.ny; } }
      });
      stepPhase = 'assign';
    }
    draw();
  }

  function animateCentroidMove(){
    return new Promise((resolve)=>{
      const duration = 400;
      const start = performance.now();
      const from = centroids.map(c=>({x:c.x,y:c.y}));
      function frame(t){
        const p = Math.min(1,(t-start)/duration);
        const ease = 0.5 - Math.cos(Math.PI*p)/2; // ease in-out
        for(let i=0;i<centroids.length;i++){
          const c = centroids[i];
          if(c.nx!==undefined){
            c.x = from[i].x + (c.nx - from[i].x)*ease;
            c.y = from[i].y + (c.ny - from[i].y)*ease;
          }
        }
        draw();
        if(p<1) requestAnimationFrame(frame);
        else resolve();
      }
      requestAnimationFrame(frame);
    });
  }

  function draw(){
    // background
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // margin
    ctx.save(); ctx.translate(10,10);

    // points
    for(const p of points){
      const col = p.cluster>=0 ? randColor(p.cluster) : '#999999';
      ctx.beginPath(); ctx.fillStyle = col; ctx.globalAlpha = 0.9; ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();
    }

    // centroids
    for(let i=0;i<centroids.length;i++){
      const c = centroids[i];
      const col = randColor(i);
      // halo
      ctx.beginPath(); ctx.fillStyle = col; ctx.globalAlpha = 0.12; ctx.arc(c.x, c.y, 18, 0, Math.PI*2); ctx.fill();
      // core
      ctx.beginPath(); ctx.fillStyle = col; ctx.globalAlpha = 1; ctx.arc(c.x, c.y, 8, 0, Math.PI*2); ctx.fill();
      // label
      ctx.font = '12px system-ui'; ctx.fillStyle = '#111'; ctx.fillText('C'+(i+1), c.x+10, c.y-10);
    }

    ctx.restore();

    // legend
    updateLegend();
  }

  function updateLegend(){
    legendDiv.innerHTML = '';
    for(let i=0;i<k;i++){
      const item = document.createElement('div'); item.className='item';
      const dot = document.createElement('div'); dot.className='dot'; dot.style.background = randColor(i);
      const txt = document.createElement('div'); txt.textContent = 'Cluster '+(i+1);
      item.appendChild(dot); item.appendChild(txt);
      legendDiv.appendChild(item);
    }
  }

  function resetAll(){
    k = parseInt(kSlider.value,10);
    points = generatePoints(parseInt(nSlider.value,10));
    initCentroids();
    stepPhase = 'assign';
    draw();
  }

  // animation loop: if playing, perform stepEvery ms
  let intervalId = null;
  function setPlaying(p){
    playing = p;
    playBtn.textContent = playing ? 'Pause' : 'Play';
    playBtn.classList.toggle('primary', !playing?false:true);
    if(playing){
      const ms = parseInt(speedSlider.value,10);
      intervalId = setInterval(()=>{ stepOnce(); }, Math.max(80, ms));
    } else {
      if(intervalId) { clearInterval(intervalId); intervalId = null; }
    }
  }

  // init
  resize();
  k = parseInt(kSlider.value,10);
  initCentroids();
  draw();

  // events
  kSlider.addEventListener('input', ()=>{
    kval.textContent = kSlider.value;
    k = parseInt(kSlider.value,10);
    // adjust centroids array length
    initCentroids();
    draw();
  });
  nSlider.addEventListener('input', ()=>{ nval.textContent = nSlider.value; });
  nSlider.addEventListener('change', ()=>{ points = generatePoints(parseInt(nSlider.value,10)); initCentroids(); draw(); });

  playBtn.addEventListener('click', ()=>{
    setPlaying(!playing);
  });
  stepBtn.addEventListener('click', ()=>{ stepOnce(); });
  resetBtn.addEventListener('click', ()=>{ points = generatePoints(parseInt(nSlider.value,10)); initCentroids(); draw(); });
  randBtn.addEventListener('click', ()=>{ points = generatePoints(parseInt(nSlider.value,10)); draw(); });

  // allow clicking to add points
  canvas.addEventListener('click', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - 10);
    const y = (e.clientY - rect.top - 10);
    points.push({x:x,y:y,cluster:-1});
    draw();
  });

  // keyboard
  window.addEventListener('keydown',(e)=>{
    if(e.key === ' ') { e.preventDefault(); setPlaying(!playing); }
    if(e.key === 'r') { points = generatePoints(parseInt(nSlider.value,10)); initCentroids(); draw(); }
    if(e.key === 's') { stepOnce(); }
  });

})();
</script>
</body>
</html>
